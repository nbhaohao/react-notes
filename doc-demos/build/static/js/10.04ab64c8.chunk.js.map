{"version":3,"sources":["pages/ErrorBoundaries/str.js"],"names":["__webpack_require__","r","__webpack_exports__","d","markdownText","code1","code2"],"mappings":"0FAAAA,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,iCAAAE,IAAAJ,EAAAG,EAAAD,EAAA,0BAAAG,IAAAL,EAAAG,EAAAD,EAAA,0BAAAI,IAAO,IAAMF,EAAY,8vCAcZC,EAAK,yxBAiCLC,EAAK","file":"static/js/10.04ab64c8.chunk.js","sourcesContent":["export const markdownText = `\n  参与工作中的项目开发的时候就感觉，前端并不流行错误处理，所以如果后端传过来的值有一点问题，整个网站就白了。\n  \n  如果用 TypeScript, 则可能会减少这种情况发生的几率；React 也提供了 错误边界 这个特性，在组件发生错误的时候，\n  \n  它可以拿出备用的 UI 页面，让一切看上去不那么白，不过文档也提到了，下面几种错误它是捕获不到的。\n  \n  * 事件处理\n  * 异步代码\n  * 服务端渲染\n  * 它自身抛出来的错误\n  \n  **注意：在开发环境下 create-react-app 仍然会显示错误堆栈的弹框，不过正式环境中不会。**\n`\nexport const code1 = `\nclass ErrorCatcher extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      showErrorUI: false\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    // 返回一个 state 值，用来渲染备用 UI\n    return {\n      showErrorUI: true\n    };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // 这个生命周期函数中适合将错误上传至服务端\n  }\n\n  render() {\n    const { showErrorUI } = this.state;\n    const { children } = this.props;\n    return showErrorUI ? (\n      <h1 style={{ color: \"red\" }}>让一切看上去不那么白。</h1>\n    ) : (\n      children\n    );\n  }\n}\n\n`\n\nexport const code2 = `\nclass NormalView extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      dataList: [{ name: \"1\" }]\n    };\n  }\n\n  boom = () => {\n    this.setState({\n      dataList: null\n    });\n  };\n\n  render() {\n    const { dataList } = this.state;\n    return (\n      <div>\n        {dataList.map(item => (\n          <span key={item.name}>{item.name}</span>\n        ))}\n        <button onClick={this.boom}>点击我触发错误</button>\n      </div>\n    );\n  }\n\n`"],"sourceRoot":""}