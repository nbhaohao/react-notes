{"version":3,"sources":["pages/Portals/str.js"],"names":["__webpack_require__","r","__webpack_exports__","d","markdownText","code1"],"mappings":"0FAAAA,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,iCAAAE,IAAAJ,EAAAG,EAAAD,EAAA,0BAAAG,IAAO,IAAMD,EAAY,0sCAQZC,EAAK","file":"static/js/11.acca8890.chunk.js","sourcesContent":["export const markdownText = `\n  在我们开发组件的时候，会存在一些特殊的组件，比如 Toast, Modal, 如果它作为某个组件的子元素，默认是挂载到最近的父节点上面的，\n  但是如果是一个 Modal 的话，就显得不那么合适了，我们更希望 Modal 可以直接被挂载到 body 上，这样它在显示的时候层级会更高。\n  那 React 提供了一个 API 来做到这个事情，作用是将任何一个可渲染的 React 组件，挂载到任意一个 DOM 元素上：\\`ReactDOM.createPortal(child, container)\\`\n  \n  **注意：即使这个元素被挂载到了其他父节点，它的事件冒泡仍然会按照 JSX 结构向上传递。**\n`\n\nexport const code1 = `\nconst BaseModalContent = ({ show, onCancel }) =>\n  show && (\n    <div style={{zIndex: 200, background: 'white', position: 'fixed', width: '200px', height: '200px', top: '50%', \n    left: '50%', transform: 'translate(-50%, -50%)', border: '1px solid tomato'}}>\n      <p>我是一个 Modal，我被挂载到 body 上了</p>\n      <button onClick={onCancel}>关闭 Modal</button>\n    </div>\n  );\n\nclass BaseModalWrapper extends PureComponent {\n  render() {\n    const { show } = this.props;\n    if (!show) {\n      return null;\n    }\n    return ReactDOM.createPortal(\n      <BaseModalContent {...this.props} />,\n      document.body\n    );\n  }\n}\n\nexport class Portals extends PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      modalVisible: false\n    };\n  }\n\n  handleChangeModalVisible = bool => () => {\n    this.setState({\n      modalVisible: bool\n    });\n  };\n\n  render() {\n    const { modalVisible } = this.state;\n    return (\n      <div>\n        <button onClick={this.handleChangeModalVisible(true)}>\n          show modal\n        </button>\n        <BaseModalWrapper\n          show={modalVisible}\n          onCancel={this.handleChangeModalVisible(false)}\n        />\n      </div>\n    );\n  }\n}\n\n\n`"],"sourceRoot":""}